#include <stdio.h>#include <stdlib.h>#include <string.h>#include "graph.h"#include "DLList.h"#include "math.h"/* 1. get collection function - reads the urls from collection.txt and places each item in a list 2. create a graph and store all data from the list into this graph - adj matrix rep 3. read from all the url txt files - and add them as edges 4. GRAPH COMPLETED 5. Calcualte page rank   */// reads in collection.txt and returns a list of URLS. This function will read the urls from collection.txt (by calling getList from List.c) and store the URLS in list lDLList getCollection(DLList l, FILE * f) {       // char * v;    //newListNode(v);    // showList(urls);    // f = fopen("collection.txt","r"); //read file    // while(fscanf(f, "%s\n",n->data) != EOF) {    // n = n->next;     //printf("%s\n", n->data);    //printf("in here\n");    l =  getDLList(f);      //  printf("dlistlenght %d\n", DLListLength(l));    return l;    }Graph getGraph(DLList l, int nV){    //creates a new graph by calling Graphnew in graph.h - adds in nV from listLength function        DLList k = listcopy(l);    DLList m = listcopy(l);       //nV = DLListLength(l);    //showDLList(l);     Graph g = newGraph(nV, k);         char urls[1000];  //  DLList k = newDLList(); //list for storing vertices connected data.    int i = 0;   // char * temp;    FILE * f;    char * txt = ".txt";    //printf("nv is %d\n",nV);    while(nV > i) {        strcat(l->first->data, txt);      f = fopen(l->first->data, "r"); //opening all url files        while((fscanf(f, "%s", urls) !=EOF) && strcmp(urls, "#end")!= 0){            if((strcmp(urls,"#start")!=0) && (strcmp(urls,"Section-1") !=0)){ //extract "url" text lines from txt files and treat as connected vertices                addEdge(g, m->first->data, urls);                          }            // printf("l->first is %s\n", l->first->data);        }        l->first = l->first->next; //move on to the next url txt file        m->first = m->first->next;        i++;        fclose(f);    }       return g;}void PageRank(float d, float diffPR, int maxIter, int nV, Graph g) {    /*    N = number of urls in the collection    For each url pi in the collection    PR(pi) = 1/N  ;    End For    */    showGraph(g, 1);    int counter;    float PR[nV]; //array for    float PROld[nV];  //  float n = (float)nV;    //float n = nV;    for(counter = 0; counter < nV; counter++) { //set initial/default PR for all the urls        PR[counter] = (1.0/nV);        //printf("n %f", n);      //printf("PR initial % f \n", PR[counter]);    }    //iteration = 0;  //  diff = diffPR; to enter the following loop    int iterCounter = 0;    float diff = diffPR;       /*     not entirely sure what diffPR will do - but diff will be updated as we find new PRs        While (iteration < maxIteration AND diff >= diffPR)    iteration++;    diff = 0;    // reset diff for each iteration        //for loop that will go through every url in the collection     For each url pi in the collection    // we assign the old PR to the new PR - because through every iteration, this will change and we need to update the diffPR variable by changing this variable        PR_old = PR(pi);    sum = 0 ; - resets the sum after an iteration        For each url pj pointing to pi (ignore self-loops and parallel edges)    sum = sum + PR(pj) / out-degree-of(pj);    End For        PR(pi) = (1-d)/N + d * sum    diff = diff + Abs(PR_old - PR(pi);        End For    end while    */        int urlCurr;    int urlConn = 0;    //int urlConn2 = 0;    float sum = 0;    int outDegreeV[nV];    int n = 0;        FILE *pr = fopen("pagerank.txt", "w");        //default value of 1 outdeegree vertex (divide by 1)    while(n < nV) {        outDegreeV[n] = 1;        n++;    }        int outDegreeC = 1;    //the loop that controls all loops inside -> when it stops, we will have finished iterating.    while (iterCounter < maxIter && (diff  >= diffPR)) {        diff = 0;        urlCurr = 0;      //  printf("h\n");        //iterate through all urls until we find one that points to our current URL.        for(urlCurr = 0; urlCurr < nV; urlCurr++) {          // printf("d\n");            PROld[urlCurr] = PR[urlCurr];            sum = 0; // reset the sum after iteration           // printf("%f pr url, urlCurr %d\n",PR[urlCurr], urlCurr);            urlConn = 0;                        while(urlConn < nV) { //check for connected components                if(isConnected(g, urlConn, urlCurr) == 1) { //need to add in self loops and parellel edge condition!!                    sum = (sum + ((PR[urlConn])/(outDegreeV[urlConn])));                                       // printf("pr[%f]]\n",PR[urlCurr]);                                      //printf("PR (sum) %f\n", sum);                }                                if(urlConn >=2 && iterCounter >= 1 && isConnected(g, urlCurr, urlConn) == 1) {                    outDegreeV[urlCurr] = (outDegreeV[urlCurr] + outDegreeC);                                }                                urlConn++;            }                        PR[urlCurr] = (1-d)/nV + d * sum;            printf("prURL[curr] %f, curr %d \n", PR[urlCurr], urlCurr);            diff = diff + fabsf(PROld[urlCurr] - PR[urlCurr]);             //create iD to vertex function            if(iterCounter == maxIter-1) {            fprintf(pr, "%d %f %d \n", urlCurr,PR[urlCurr],outDegreeV[urlCurr]);            }        }            /*        PR(pi) = (1-d)/N + d * sum        diff = diff + Abs(PR_old - PR(pi);         */          iterCounter++;        }    fclose(pr);    }